# RFC 3161 Timestamp Receipts

ClaimLedger supports RFC 3161 timestamp receipts — cryptographic proofs from a Timestamp Authority (TSA) that a claim existed at a specific point in time.

## What RFC 3161 Timestamps Prove

An RFC 3161 timestamp token proves:

> "A TSA with certificate C signed: hash H existed at time T"

Unlike witness attestations (which use ClaimLedger keys), RFC 3161 tokens use established TSA infrastructure with X.509 certificates.

## When to Use RFC 3161 vs Witness Timestamps

| Feature | RFC 3161 (TSA) | Witness Attestation |
|---------|----------------|---------------------|
| Trust model | X.509 PKI | Ed25519 keys you control |
| External service | Yes (TSA required) | No |
| Legal recognition | Often accepted | Depends on jurisdiction |
| Offline creation | No | Yes |
| Works without keys | Yes | No |
| Cost | Often free (FreeTSA) | Free |

**Use RFC 3161 when:**
- Legal/regulatory compliance requires established TSA
- You need third-party attestation without managing keys
- Working with parties who trust X.509 PKI

**Use Witness attestations when:**
- You control both sides (internal timestamping)
- Fully offline operation required
- You prefer Ed25519 over X.509

## CLI Usage

### Step 1: Create Timestamp Request

```bash
# Create a .tsq file (TimeStampRequest)
claimledger tsa-request claim.json --out claim.tsq

# With explicit nonce
claimledger tsa-request claim.json --nonce "0102030405060708" --out claim.tsq
```

This creates a binary `.tsq` file containing:
- SHA-256 of `claim_core_digest` bytes (the message imprint)
- Request for TSA certificate inclusion

### Step 2: Submit to TSA (Out-of-Band)

Send the `.tsq` file to an RFC 3161 TSA:

```bash
# FreeTSA (free, no account required)
curl -H "Content-Type: application/timestamp-query" \
     --data-binary @claim.tsq \
     https://freetsa.org/tsr \
     -o claim.tsr

# DigiCert (requires account)
curl -H "Content-Type: application/timestamp-query" \
     -H "Authorization: Basic <credentials>" \
     --data-binary @claim.tsq \
     https://timestamp.digicert.com \
     -o claim.tsr
```

### Step 3: Attach Token to Bundle

```bash
claimledger tsa-attach claim.json --token claim.tsr --out claim.tsa.json
```

This:
1. Parses and validates the CMS/PKCS#7 token
2. Verifies the message imprint matches your claim
3. Appends the receipt to `timestamp_receipts[]`

### Verification

```bash
# Basic verification (Level 1: signature + binding)
claimledger verify claim.tsa.json --tsa

# With trust validation (Level 2: certificate chain)
claimledger verify claim.tsa.json --tsa --tsa-trust-dir ./tsa-certs/

# Strict mode (fail if untrusted)
claimledger verify claim.tsa.json --tsa --tsa-trust-dir ./tsa-certs/ --strict-tsa
```

### List Timestamps

```bash
claimledger timestamps claim.tsa.json
```

## Verification Levels

### Level 1: Token Integrity + Binding

Always performed. Verifies:
- CMS/PKCS#7 signature is cryptographically valid
- Content type is `id-ct-TSTInfo` (RFC 3161)
- Hash algorithm is SHA-256 (v1 requirement)
- Message imprint matches `SHA256(claim_core_digest_bytes)`

**Exit code 3** if Level 1 fails (broken).

### Level 2: Trust Validation

Only when `--tsa-trust-dir` is provided. Verifies:
- Certificate chain builds to provided trust anchors
- Signer cert was valid at `genTime`
- Signer cert has Time Stamping EKU (1.3.6.1.5.5.7.3.8)

**No exit code change** for Level 2 failures in non-strict mode (just warnings).
**Exit code 3** if `--strict-tsa` and trust validation fails.

### Offline Verification

ClaimLedger never fetches CRLs or performs OCSP checks. Trust validation is **offline only**.

If you need revocation checking:
1. Download CRLs manually
2. Verify TSA certificate status separately
3. Consider using a different trust anchor if TSA cert is revoked

## Receipt Format

```json
{
  "timestamp_receipts": [
    {
      "contract": "TimestampReceiptRFC3161.v1",
      "receipt_id": "uuid",
      "subject": {
        "kind": "CLAIM_CORE_DIGEST",
        "digest_hex": "sha256-of-claim-core"
      },
      "hash_algorithm": "SHA-256",
      "message_imprint_hex": "sha256-of-claim-core-digest-bytes",
      "tsa_token_der_base64": "base64(CMS-SignedData)",
      "issued_at": "2024-06-15T12:00:00.0000000Z",
      "tsa": {
        "policy_oid": "1.2.3.4",
        "serial_number_hex": "1234",
        "cert_fingerprint_sha256_hex": "abcd..."
      }
    }
  ]
}
```

## Message Imprint Definition

ClaimLedger timestamps the **digest of the digest**:

```
message_imprint = SHA-256(bytes_from_hex(claim_core_digest))
```

Why not timestamp the claim JSON directly?
- JSON canonicalization edge cases
- Claim JSON can be large
- Digest-of-digest is stable and compact

The `claim_core_digest` already captures the claim's identity:
- Claim ID, statement, researcher
- Evidence hashes
- Citations
- **NOT** attestations or timestamp receipts (append-only)

## Trust Anchors

Create a directory with TSA certificates:

```
tsa-certs/
├── freetsa-root.cer
├── digicert-root.pem
└── internal-tsa.der
```

Supported formats:
- `.cer`, `.crt` — DER or PEM
- `.pem` — PEM with headers
- `.der` — Raw DER

```bash
# Verify with trust anchors
claimledger verify claim.tsa.json --tsa --tsa-trust-dir ./tsa-certs/
```

## Multiple Timestamps

You can attach multiple TSA receipts:

```bash
# First TSA
claimledger tsa-request claim.json --out claim.tsq
curl ... claim.tsq > claim.tsr
claimledger tsa-attach claim.json --token claim.tsr --out claim.tsa1.json

# Second TSA
claimledger tsa-request claim.tsa1.json --out claim2.tsq
curl ... claim2.tsq > claim2.tsr
claimledger tsa-attach claim.tsa1.json --token claim2.tsr --out claim.tsa2.json
```

All receipts bind to the same `claim_core_digest`.

## Exit Codes

| Code | Meaning |
|------|---------|
| 0 | Valid — timestamps verified |
| 3 | Broken — invalid token, imprint mismatch, or trust failure in strict mode |
| 4 | Invalid input |
| 5 | Error |

## Security Notes

### What RFC 3161 Does NOT Prove

- **Not** that the claim is true
- **Not** that the signer was authorized
- **Not** that the TSA verified the claim content

It only proves: "This hash existed when the TSA signed it."

### TSA Selection

Choose a TSA based on:
- Legal/regulatory requirements
- Trust anchor availability
- Long-term certificate validity
- Policy OID if required

### Key Compromise

If a TSA's key is compromised:
- Old timestamps may still be valid (depends on when compromise occurred)
- Update your trust anchors to exclude the compromised cert
- Consider adding timestamps from additional TSAs

### Long-Term Validation

For long-term archives (10+ years):
1. Use multiple independent TSAs
2. Preserve TSA certificate chains
3. Periodically re-timestamp with current algorithms
4. Keep CRLs if you need revocation evidence

## Comparison with Witness Timestamps

| Aspect | RFC 3161 | Witness Attestation |
|--------|----------|---------------------|
| Contract | `TimestampReceiptRFC3161.v1` | `AttestationSignable.v1` |
| Type | — | `WITNESSED_AT` |
| Signature | CMS/PKCS#7 (RSA/ECDSA) | Ed25519 |
| Stored in | `timestamp_receipts[]` | `attestations[]` |
| Binding | `SHA256(claim_core_digest_bytes)` | `claim_core_digest` |

Both can coexist in the same bundle.

## Backwards Compatibility

- Phase 1-5 bundles verify unchanged
- `timestamp_receipts` is a new optional array
- Existing verifiers ignore unknown fields
